/*
    This source file is generated by sotom at 2022-07-22 23:23:16.847133
    visit sotom at https://github.com/sislamrafi/sotom
*/

#include "flash.h"
#include "_flash.h"

// write your functions here

static inline void waitUntilFlashNotBSY() {
  while (FLASH->SR & (1 << 16))
    ; // wait for BSY bit to 0
}

void unlockFlash() {
  waitUntilFlashNotBSY();
  FLASH->KYER = 0x45670123; // KEY1
  FLASH->KYER = 0xCDEF89AB; // KEY2
  waitUntilFlashNotBSY();
}

void lockFlash() {
  waitUntilFlashNotBSY();
  FLASH->CR |= (1 << 31); // setting the lock bit
  waitUntilFlashNotBSY();
}

void eraseSector(uint8_t _sector) {
  waitUntilFlashNotBSY();
  uint32_t CR = FLASH->CR;
  CR |= (1 << 1);       // SER BIT SET 1
  CR &= ~(1111 << 3);   // SET SNB to 0000
  CR |= (_sector << 3); // Write SNB
  FLASH->CR |= CR;
  FLASH->CR |= (1 << 16); // STRT BIT SET 1
  waitUntilFlashNotBSY();
}

void eraseDataSectorIfNeed() {
  if (flash_data_read8t(FLASH_DATA_SECTOR_STATUS_BYTE_POS) == 0xff)
    return;
  unlockFlash();
  eraseSector(FLASH_DATA_SECTOR);
  lockFlash();
}

uint8_t flash_data_read8t(uint32_t position) {
  waitUntilFlashNotBSY();
  return *((uint8_t *)FLASH_DATA_SECTOR_START + position);
}

void flash_data_write8t(uint8_t data, uint32_t position) {
  // position 0 is for status byte, dont write it untill you need erase
  if (position == 0)
    return;
  if (flash_data_read8t(position) == data)
    return; // no write operation on same value
  unlockFlash();
  FLASH->CR |= (1 << 0); // Set the PG bit to 1
  *((uint8_t *)FLASH_DATA_SECTOR_START + position) = data;
  waitUntilFlashNotBSY();
  FLASH->CR &= ~(1 << 0); // Set the PG bit to 0
  lockFlash();
}

void flashDataSectorEraseNeed() {
  unlockFlash();
  FLASH->CR |= (1 << 0); // Set the PG bit to 1
  *((uint8_t *)FLASH_DATA_SECTOR_START) = 0x0;
  waitUntilFlashNotBSY();
  FLASH->CR &= ~(1 << 0); // Set the PG bit to 0
  lockFlash();
}
